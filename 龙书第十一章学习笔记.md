# 11.1 基本概念
## Amdahl定律
如果 $\mathcal{f}$ 是被并行化代码的比率，并且如果并行化版本在一个有 $\mathcal{p}$ 个处理器的机器上运行，且没有任何通信或者并行化开销，那么此时的加速比是:

$$\frac{1}{(1 - \mathcal{f}) + (\mathcal{f} / \mathcal{p})}$$

## 循环层次上的并行性
>循环是并行化的主要目标，找到循环中相互独立的迭代，将这些迭代分配给多个处理器。

例子：
```cpp
//代码1，原始代码
for (i = 0; i < n; ++i>) {
    z[i] = x[i] - y[i];
    z[i] = z[i] * z[i];
}

//代码2， 并行代码
//循环中的迭代平均分配给各个处理器，第p个处理器被分配执行第p组循环
b = ceil(n / M)     // n 为循环次数，M为处理器个数,ceil() 为向上取整
for (int i = b * p; i < min(n, b * (p + 1)); ++i) {
    '''
    i < min(n, b * (p + 1)) 是为了判断，
    如果此时进程i的编号小于循环个数，则其他处理器不会进行操作
    '''
    z[i] = x[i] - y[i];
    z[i] = z[i] * z[i];
}
```

上述的并行代码是一个SPMD(Single Program Multiple Data, 单程序多数据)

### 循环层次的并行
将循环中的互相独立的迭代分配给不同的处理器。
### 任务层次上的迭代
将不同函数的调用过着两个独立的循环分配给不同的处理器。但是如果要对程序进行并行性处理，任务层次不会得到太多的关注，因为对没个程序来说，相互独立的任务数是固定的，不能随着数据大小的增加而增加。而循环中的迭代次数会因为数据量的增加而增加。

## 数据局部性
C++中数组元素是按行进行存储的。
```cpp
//代码3，按行将数组置零
for (i = 0; i < n; ++i) {
    for (j = 0; j < n; ++j) {
        z[i][j] = 0;
    }
}

//代码4，并行按行将数组置零
b = ceil(n / M);
for (i = b * p; i < min(n, b * (p + 1)); ++i) {
    for (j = 0; j < n; ++j) {
        z[i][j] = 0
    }
}
```

## 仿射变换理论概述
### 循环优化问题空间
+ 迭代空间（iteration space）：
  在一些计算过程中动态执行示例的集合，也就是各个循环下标的取值的组合。
+ 数据空间（data space）：
  被访问的数组元素的集合。
+ 处理器空间（processor space）：
  系统中处理器的集合。通常情况下，这些树立起使用整数或者整数向量进行编号。

##### 优化问题的输入与输出
+ 输入：
  各个迭代被执行的串行顺序以及一个仿射的数组访问函数（比如，X[i, j + 1]）。这个函数描述了迭代空间中的哪个实例访问数据空间中的哪个元素
+ 输出：
  用仿射函数表示，定义了没个处理器在什么时候做什么事。
    * 什么事情：
      使用一个仿射函数将原迭代空间中的实例映射到各个处理器上。
    * 什么时候执行：
      使用一个仿射函数将迭代空间中的实例映射成为一个新的顺序。

具体分析例子，龙书P494

# 11.3 迭代空间
## 迭代空间
作为外层循环下标的一个仿射函数，每个循环的上下界都定义了一个不等式，它把空间分成了两半：对应循环迭代部分（即正的半空间）和不对应迭代的部分（即负的半空间）。所有的线性不等式的交（逻辑AND）表示这些正的半空间的交集，该交集定义了一个凸多面体（convex polyhedron）。这个多面体就是这个循环嵌套结构的迭代空间。

>迭代空间是数组中被代码访问到的部分，与数据空间不一定完全相同。

## 投影
把表示迭代空间的凸多面体投影到改空间中对应于较外层循环的维度上。可以用投影的方式生成循环界限。
### Fourier-Motzkin 消除算法
**输入**：一个带有变量x<sub>1</sub>, x<sub>2</sub>, $\cdots$, x<sub>n</sub>的多面体S。也就是说，S是关于变量x<sub>i</sub>的一组线性约束。一个给定的变量x<sub>m</sub>是被指定需要消除的变量。
**输出**：一个关于x<sub>1</sub>, x<sub>2</sub>, $\cdots$, x<sub>m - 1</sub>, $\cdots$, x<sub>m + 1</sub>, $\cdots$, x<sub>n</sub>(即除了x<sub>m</sub>以外的所有S的变量)的多面体S'。S'是S到除第m个维度之外的所有维度的投影。
**方法**：龙书P504 - 505

## 11.4 仿射的数组下标
**<center>仿射变换 = 线性变换 + 平移</center>**
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/hehuanxiang/PIgo/master/202110211038745.gif?token=ALRSGDOSVT27METL3L6ZLK3BODJOO">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">仿射变换示意图</div>
</center>

### 仿射访问
如果下列条件同时成立，我们就说一个循环中的一个数组访问是仿射的。
+ 该循环的上下界被表示为外围循环变量和符合常量的仿射表达式。
+ 该数组的每个维度的下标也是外围循环变量和符号常量的仿射表达式。

仿射数组访问的例子有Z[i], Z[i + j + 1], Z[0]，但是Z[i * j]和Z[n * j]不是仿射访问。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/hehuanxiang/PIgo/master/202110211039060.PNG?token=ALRSGDNNTSHQFIG73DTV2YTBODJSO">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">一些数组访问和它们的矩阵 - 向量表示 矩阵F和向量f</div>
</center>

### 非仿射访问
+ 涉及稀疏矩阵的程序。（但是如果稀疏情况是规律的，比如一个带状矩阵，即非零元素都集中在对角线周围，数组的访问仍可能是仿射的。）
+ 线性化数组。即在编译时多维数组的某一维度可能未知。
```cpp
j = n;
for (i = 0; i <= n; ++i) {
    Z[j] = 0;
    j = j + 2;
}
```
改写成：
```cpp
\\ 对Z数组的访问变成仿射访问
j = n;
for (i = 0; i <= n; ++i) {
    Z[n + 2 * i] = 0;
}
```

## 11.5 数据复用
对于局部性优化，我们希望识别出访问相同数据或相同高速缓存线的迭代组合。
+ **静态访问**：
  访问指令本身。
+ **动态访问**：
  执行该循环嵌套结构时该语句的多次迭代。
+ 时间复用：复用指向完全相同的位置。
+ 空间复用：复用指向同一个高速缓存线。
### 数据复用的类型
数据复用可以分为**自复用**和**组复用**两种。
#### 自复用
定义：复用同样的数据的多个迭代源于同一个静态访问。
如果一个静态访问所指向的数据具有k个维度，且这个循环嵌套在一个深度为d(d > k)的循环结构中，那么同一个数据可以被复用n<sup>d - k</sup>次。
##### 矩阵的零空间
给定矩阵 $\mathcal{A}$ $\in$ $\mathcal{R}$ <sup>m $\times$ n</sup>，那么矩阵的零空间定义为：
如果*X* ∈ $\mathcal{R}$ <sup>n $\times$ 1</sup>，且有 $\mathcal{A}$ *X* = 0 那么所有这样的X组成的线性空间就是矩阵A的零空间。
##### 矩阵的零度
矩阵零空间的维度称为矩阵的零度（nullity）。
>**秩-零定理（The Rank-Nullity Theorem）**
给定矩阵$\mathcal{A}$ $\in$ $\mathcal{R}$ <sup>m $\times$ n</sup>，我们有
$$\mathcal{rank(A)} + \mathcal{nullity(A)} = n$$若零数为0，则说明所有的迭代都指向不同的位置，不存在复用的可能。

零空间的基本向量是矩阵F作为系数矩阵对应齐次方程的解。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src="https://raw.githubusercontent.com/hehuanxiang/PIgo/master/202110211040403.PNG?token=ALRSGDOPNPFLMIFGXW7GI23BODJUO">
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">仿射访问的秩和零数</div>
</center>

##### 自空间复用
空间复用的分析依赖于矩阵的数据布局。C语言的矩阵是按行存放的，Fortran语言的矩阵是按列存放的。
> 发现和利用自空间复用的技巧是不考虑系数矩阵**F**中的最后一行。如果得到的截短后的矩阵的秩小于循环嵌套结构的深度，那么我们就可以确保最内层循环只改变数组的最后下标的值，从而保证空间局部性。

例子分析：龙书P513
#### 组复用
复用同样的数据的多个迭代源**不**源于同一个静态访问。
我们只在同一个循环中具有相同系数矩阵的数组访问之间计算组复用。
>给定两个动态访问 *Fi*<sub>1</sub> + *f*<sub>1</sub> 和 *Fi*<sub>2</sub> + *f*<sub>2</sub>，它们复用相同数据的条件是:
$$Fi_1 + f_1 = Fi_2 + f_2$$$$F(i_1 - i_2) = (f_1 - f_2)$$

## 11.6 数组数据依赖关系分析
如果两个访问指向同一个内存位置并且其中至少有一个写运算，那么就说这两个访问是数据依赖的。
### 数据依赖的三种类型
+ 真依赖：
  一个写运算后跟一个对同一个内存位置的读运算。
+ 反依赖：
  一个读运算后跟一个对同一个内存位置的写运算。
+ 输出依赖：
  是两个针对同一个位置的写运算。

### 整数线性规划
>整数线性规划是指要求一部分或全部决策变量必须取整数值的线性规划问题。
线性规划特指目标函数和约束条件皆为线性的最优化问题。

对数据依赖关系的分析要求找出是否存在一些整数满足由等式和不等式组成的约束系统。
+ 等式：
  从数组访问的矩阵 - 向量中得到。
  等式可以又不等式表示，如x = y 可以表示为 x $\leq$ y 和 y $\leq$ x 表示。
+ 不等式：
  从循环边界中得到。

因此，
<center>数据依赖关系问题 = 寻找满足一组线性不等式的整数解</center>

#### 数据依赖分析算法
算法由三个部分组成。
1. 使用丢番图方程理论，应用GCD（Greatest Common Divisor，最大公约数）测试检验是否存在满足问题中所有等式的整数解。若无，则不存在数据依赖关系；反之，则存在。
2. 使用一组简单的启发规则来处理大量典型不等式。
   + 启发式算法
     启发式算法（heuristic algorithm)是相对于最优化算法提出的。一个问题的最优算法求得该问题每个实例的最优解。启发式算法可以这样定义：一个基于直观或经验构造的算法，在可接受的花费（指计算时间和空间）下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计。现阶段，启发式算法以仿自然体算法为主，主要有蚁群算
3. 在少数情况下，这些启发式规则可能还解决不了问题。此时，我们使用线性整数规划求解程序来解决问题。这些程序基于**Fourier-Motzkin 消除算法**，使用了一种分支并设限的方法来求解。




